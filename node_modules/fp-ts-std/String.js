"use strict";
/**
 * @since 0.1.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = exports.unlines = exports.lines = exports.reverse = exports.split = exports.matchAll = exports.match = exports.takeRight = exports.takeLeft = exports.unsurround = exports.surround = exports.unappend = exports.append = exports.unprepend = exports.prepend = exports.concat = exports.endsWith = exports.startsWith = exports.trimRight = exports.trimLeft = exports.trim = exports.contains = exports.isEmpty = exports.isString = exports.fromNumber = exports.length = void 0;
const function_1 = require("fp-ts/function");
const O = require("fp-ts/Option");
const NEA = require("fp-ts/NonEmptyArray");
const A = require("fp-ts/Array");
const Array_1 = require("./Array");
/**
 * Get the length of a string.
 *
 * @since 0.1.0
 */
exports.length = (x) => x.length;
/**
 * Convert a number to a string.
 *
 * @since 0.1.0
 */
exports.fromNumber = (x) => String(x);
/**
 * Refine a foreign value to a string.
 *
 * @since 0.1.0
 */
exports.isString = (x) => typeof x === 'string';
/**
 * Check if a string is empty.
 *
 * @since 0.1.0
 */
exports.isEmpty = (x) => x === '';
/**
 * Check if a string contains a given substring.
 *
 * @since 0.1.0
 */
exports.contains = (substring) => (target) => target.includes(substring);
/**
 * Trim both sides of a string.
 *
 * @since 0.1.0
 */
exports.trim = (x) => x.trim();
/**
 * Trim the left side of a string.
 *
 * @since 0.1.0
 */
exports.trimLeft = (x) => x.trimLeft();
/**
 * Trim the right side of a string.
 *
 * @since 0.1.0
 */
exports.trimRight = (x) => x.trimRight();
/**
 * Check if a string starts with the specified substring.
 *
 * @since 0.3.0
 */
exports.startsWith = (substring) => y => y.startsWith(substring);
/**
 * Check if a string ends with the specified substring.
 *
 * @since 0.3.0
 */
exports.endsWith = (substring) => y => y.endsWith(substring);
/**
 * Concatenate two strings together.
 *
 * @since 0.1.0
 */
exports.concat = (x) => (y) => x + y;
/**
 * Prepend one string to another.
 *
 * @since 0.1.0
 */
exports.prepend = (prepended) => (rest) => prepended + rest;
/**
 * Remove the beginning of a string, if it exists.
 *
 * @since 0.1.0
 */
exports.unprepend = (start) => (val) => val.startsWith(start)
    ? val.substring(start.length)
    : val;
/**
 * Append one string to another.
 *
 * @since 0.1.0
 */
exports.append = (appended) => (rest) => rest + appended;
/**
 * Remove the end of a string, if it exists.
 *
 * @since 0.1.0
 */
exports.unappend = (end) => (val) => val.endsWith(end)
    ? val.substring(0, val.lastIndexOf(end))
    : val;
/**
 * Surround a string. Equivalent to calling `prepend` and `append` with the
 * same outer value.
 *
 * @since 0.1.0
 */
exports.surround = (x) => function_1.flow(exports.prepend(x), exports.append(x));
/**
 * Remove the start and end of a string, if they both exist.
 *
 * @since 0.1.0
 */
exports.unsurround = (x) => val => val.startsWith(x) && val.endsWith(x)
    ? function_1.pipe(val, exports.unprepend(x), exports.unappend(x))
    : val;
/**
 * Keep the specified number of characters from the start of a string.
 *
 * If `n` is larger than the available number of characters, the string will
 * be returned whole.
 *
 * If `n` is not a positive number, an empty string will be returned.
 *
 * If `n` is a float, it will be rounded down to the nearest integer.
 *
 * @since 0.3.0
 */
exports.takeLeft = (n) => x => x.slice(0, Math.max(0, n));
/**
 * Keep the specified number of characters from the end of a string.
 *
 * If `n` is larger than the available number of characters, the string will
 * be returned whole.
 *
 * If `n` is not a positive number, an empty string will be returned.
 *
 * If `n` is a float, it will be rounded down to the nearest integer.
 *
 * @since 0.3.0
 */
exports.takeRight = (n) => x => x.slice(Math.max(0, x.length - Math.floor(n)));
/**
 * Functional wrapper around `String.prototype.match`.
 *
 * @since 0.1.0
 */
exports.match = (r) => (x) => O.fromNullable(x.match(r));
/**
 * A functional wrapper around `String.prototype.matchAll`.
 *
 * If the provided `RegExp` is non-global, the function will return `None`.
 *
 * @since 0.5.0
 */
exports.matchAll = (r) => (x) => function_1.pipe(O.tryCatch(() => x.matchAll(r)), O.chain(function_1.flow(xs => Array.from(xs), NEA.fromArray)));
/**
 * Split a string into substrings using the specified separator and return them
 * as an array.
 *
 * @since 0.1.0
 */
exports.split = (on) => (target) => target.split(on);
/**
 * Reverse a string.
 *
 * @example
 * import { reverse } from 'fp-ts-std/String';
 *
 * assert.strictEqual(reverse('abc'), 'cba');
 *
 * @since 0.3.0
 */
exports.reverse = function_1.flow(exports.split(''), A.reverse, Array_1.join(''));
// The regex comes from here: https://stackoverflow.com/a/20056634
/**
 * Split a string into substrings using any recognised newline as the separator.
 *
 * @since 0.1.0
 */
exports.lines = exports.split(/\r\n|\r|\n/);
/**
 * Join newline-separated strings together.
 *
 * @since 0.1.0
 */
exports.unlines = Array_1.join('\n');
/**
 * A functional wraper around `RegExp.prototype.test`.
 *
 * @since 0.1.0
 */
exports.test = (r) => x => r.test(x);
