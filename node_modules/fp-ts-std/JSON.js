"use strict";
/**
 * @since 0.1.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseO = exports.parse = exports.unstringify = exports.stringifyPrimitive = exports.stringifyO = exports.stringify = void 0;
const newtype_ts_1 = require("newtype-ts");
const E = require("fp-ts/Either");
const O = require("fp-ts/Option");
const function_1 = require("fp-ts/function");
const String_1 = require("./String");
const { wrap: mkJSONString, unwrap: unJSONString } = newtype_ts_1.iso();
/**
 * Stringify some arbitrary data.
 *
 * @since 0.1.0
 */
exports.stringify = (f) => (x) => function_1.pipe(
// It should only throw some sort of `TypeError`:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
E.stringifyJSON(x, (e) => f(e)), E.filterOrElse(String_1.isString, () => f(new TypeError('Stringify output not a string'))), E.map(mkJSONString));
/**
 * Stringify some arbitrary data, returning an `Option`.
 *
 * @since 0.1.0
 */
exports.stringifyO = function_1.flow(exports.stringify(function_1.identity), O.fromEither);
/**
 * Stringify a primitive value with no possibility of failure.
 *
 * @since 0.1.0
 */
exports.stringifyPrimitive = (x) => function_1.pipe(x, JSON.stringify, mkJSONString);
/**
 * Parse a string as JSON. This is safe provided there have been no shenanigans
 * with the `JSONString` newtype.
 *
 * @since 0.5.0
 */
exports.unstringify = function_1.flow(unJSONString, JSON.parse);
/**
 * Parse a string as JSON.
 *
 * @since 0.1.0
 */
exports.parse = (f) => (x) => 
// It should only throw some sort of `SyntaxError`:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
E.parseJSON(x, (e) => f(e));
/**
 * Parse a string as JSON, returning an `Option`.
 *
 * @since 0.1.0
 */
exports.parseO = function_1.flow(exports.parse(function_1.identity), O.fromEither);
