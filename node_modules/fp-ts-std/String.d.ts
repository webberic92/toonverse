/**
 * @since 0.1.0
 */
import { Predicate, Refinement, Endomorphism } from 'fp-ts/function';
import { Option } from 'fp-ts/Option';
import { NonEmptyArray } from 'fp-ts/NonEmptyArray';
/**
 * Get the length of a string.
 *
 * @since 0.1.0
 */
export declare const length: (x: string) => number;
/**
 * Convert a number to a string.
 *
 * @since 0.1.0
 */
export declare const fromNumber: (x: number) => string;
/**
 * Refine a foreign value to a string.
 *
 * @since 0.1.0
 */
export declare const isString: Refinement<unknown, string>;
/**
 * Check if a string is empty.
 *
 * @since 0.1.0
 */
export declare const isEmpty: Predicate<string>;
/**
 * Check if a string contains a given substring.
 *
 * @since 0.1.0
 */
export declare const contains: (substring: string) => Predicate<string>;
/**
 * Trim both sides of a string.
 *
 * @since 0.1.0
 */
export declare const trim: Endomorphism<string>;
/**
 * Trim the left side of a string.
 *
 * @since 0.1.0
 */
export declare const trimLeft: Endomorphism<string>;
/**
 * Trim the right side of a string.
 *
 * @since 0.1.0
 */
export declare const trimRight: Endomorphism<string>;
/**
 * Check if a string starts with the specified substring.
 *
 * @since 0.3.0
 */
export declare const startsWith: (substring: string) => Predicate<string>;
/**
 * Check if a string ends with the specified substring.
 *
 * @since 0.3.0
 */
export declare const endsWith: (substring: string) => Predicate<string>;
/**
 * Concatenate two strings together.
 *
 * @since 0.1.0
 */
export declare const concat: (x: string) => Endomorphism<string>;
/**
 * Prepend one string to another.
 *
 * @since 0.1.0
 */
export declare const prepend: (prepended: string) => (rest: string) => string;
/**
 * Remove the beginning of a string, if it exists.
 *
 * @since 0.1.0
 */
export declare const unprepend: (start: string) => (val: string) => string;
/**
 * Append one string to another.
 *
 * @since 0.1.0
 */
export declare const append: (appended: string) => (rest: string) => string;
/**
 * Remove the end of a string, if it exists.
 *
 * @since 0.1.0
 */
export declare const unappend: (end: string) => (val: string) => string;
/**
 * Surround a string. Equivalent to calling `prepend` and `append` with the
 * same outer value.
 *
 * @since 0.1.0
 */
export declare const surround: (x: string) => Endomorphism<string>;
/**
 * Remove the start and end of a string, if they both exist.
 *
 * @since 0.1.0
 */
export declare const unsurround: (x: string) => Endomorphism<string>;
/**
 * Keep the specified number of characters from the start of a string.
 *
 * If `n` is larger than the available number of characters, the string will
 * be returned whole.
 *
 * If `n` is not a positive number, an empty string will be returned.
 *
 * If `n` is a float, it will be rounded down to the nearest integer.
 *
 * @since 0.3.0
 */
export declare const takeLeft: (n: number) => Endomorphism<string>;
/**
 * Keep the specified number of characters from the end of a string.
 *
 * If `n` is larger than the available number of characters, the string will
 * be returned whole.
 *
 * If `n` is not a positive number, an empty string will be returned.
 *
 * If `n` is a float, it will be rounded down to the nearest integer.
 *
 * @since 0.3.0
 */
export declare const takeRight: (n: number) => Endomorphism<string>;
/**
 * Functional wrapper around `String.prototype.match`.
 *
 * @since 0.1.0
 */
export declare const match: (r: RegExp) => (x: string) => Option<RegExpMatchArray>;
/**
 * A functional wrapper around `String.prototype.matchAll`.
 *
 * If the provided `RegExp` is non-global, the function will return `None`.
 *
 * @since 0.5.0
 */
export declare const matchAll: (r: RegExp) => (x: string) => Option<NonEmptyArray<RegExpMatchArray>>;
/**
 * Split a string into substrings using the specified separator and return them
 * as an array.
 *
 * @since 0.1.0
 */
export declare const split: (on: string | RegExp) => (target: string) => Array<string>;
/**
 * Reverse a string.
 *
 * @example
 * import { reverse } from 'fp-ts-std/String';
 *
 * assert.strictEqual(reverse('abc'), 'cba');
 *
 * @since 0.3.0
 */
export declare const reverse: Endomorphism<string>;
/**
 * Split a string into substrings using any recognised newline as the separator.
 *
 * @since 0.1.0
 */
export declare const lines: (target: string) => Array<string>;
/**
 * Join newline-separated strings together.
 *
 * @since 0.1.0
 */
export declare const unlines: (ys: string[]) => string;
/**
 * A functional wraper around `RegExp.prototype.test`.
 *
 * @since 0.1.0
 */
export declare const test: (r: RegExp) => Predicate<string>;
