/**
 * @since 0.1.0
 */
import { Newtype } from 'newtype-ts';
import { Either } from 'fp-ts/Either';
import { Option } from 'fp-ts/Option';
/**
 * Newtype representing stringified JSON.
 *
 * @since 0.5.0
 */
export declare type JSONString = Newtype<{
    readonly JSONString: unique symbol;
}, string>;
/**
 * Stringify some arbitrary data.
 *
 * @since 0.1.0
 */
export declare const stringify: <E>(f: (e: TypeError) => E) => (x: unknown) => Either<E, JSONString>;
/**
 * Stringify some arbitrary data, returning an `Option`.
 *
 * @since 0.1.0
 */
export declare const stringifyO: (data: unknown) => Option<JSONString>;
/**
 * Stringify a primitive value with no possibility of failure.
 *
 * @since 0.1.0
 */
export declare const stringifyPrimitive: (x: string | number | boolean | null) => JSONString;
/**
 * Parse a string as JSON. This is safe provided there have been no shenanigans
 * with the `JSONString` newtype.
 *
 * @since 0.5.0
 */
export declare const unstringify: (x: JSONString) => unknown;
/**
 * Parse a string as JSON.
 *
 * @since 0.1.0
 */
export declare const parse: <E>(f: (e: SyntaxError) => E) => (x: string) => Either<E, unknown>;
/**
 * Parse a string as JSON, returning an `Option`.
 *
 * @since 0.1.0
 */
export declare const parseO: (stringified: string) => Option<unknown>;
