/**
 * @since 0.1.0
 */
import { Predicate } from 'fp-ts/function';
import { Eq } from 'fp-ts/Eq';
import { Ord } from 'fp-ts/Ord';
import { NonEmptyArray } from 'fp-ts/NonEmptyArray';
import { Option } from 'fp-ts/Option';
/**
 * Get the length of an array.
 *
 * @since 0.1.0
 */
export declare const length: (xs: Array<unknown>) => number;
/**
 * Like `fp-ts/Array::elem`, but flipped.
 *
 * @since 0.1.0
 */
export declare const elemFlipped: <A>(eq: Eq<A>) => (xs: A[]) => Predicate<A>;
/**
 * Check if a predicate holds true for any array member.
 *
 * @since 0.1.0
 */
export declare const any: <A>(f: Predicate<A>) => Predicate<A[]>;
/**
 * Check if a predicate holds true for every array member.
 *
 * @since 0.1.0
 */
export declare const all: <A>(f: Predicate<A>) => Predicate<A[]>;
/**
 * Join an array of strings together into a single string using the supplied
 * separator.
 *
 * @since 0.1.0
 */
export declare const join: (x: string) => (ys: Array<string>) => string;
/**
 * Like `fp-ts/Array::getEq`, but items are not required to be in the same
 * order to determine equivalence. This function is therefore less efficient,
 * and `getEq` should be preferred on ordered data.
 *
 * @since 0.1.0
 */
export declare const getDisorderedEq: <A>(ordA: Ord<A>) => Eq<A[]>;
/**
 * Pluck the first item out of an array matching a predicate. Any further
 * matches will be left untouched.
 *
 * This can be thought of as analagous to `fp-ts/Array::findFirst` where
 * the remaining items, sans the match (if any), are returned as well.
 *
 * @since 0.1.0
 */
export declare const pluckFirst: <A>(p: Predicate<A>) => (xs: A[]) => [Option<A>, A[]];
/**
 * Update an item in an array or, if it's not present yet, insert it.
 *
 * If the item exists more than once (as determined by the supplied `Eq`
 * instance), only the first to be found will be updated. The order in which
 * the array is checked is unspecified.
 *
 * @since 0.1.0
 */
export declare const upsert: <A>(eqA: Eq<A>) => (x: A) => (ys: A[]) => NonEmptyArray<A>;
/**
 * Insert all the elements of an array into another array at the specified
 * index. Returns `None` if the index is out of bounds.
 *
 * The array of elements to insert must be non-empty.
 *
 * @example
 * import { insertMany } from 'fp-ts-std/Array';
 * import * as O from 'fp-ts/Option';
 *
 * const f = insertMany(1)(['a', 'b']);
 * assert.deepStrictEqual(f([]), O.none);
 * assert.deepStrictEqual(f(['x']), O.some(['x', 'a', 'b']));
 * assert.deepStrictEqual(f(['x', 'y']), O.some(['x', 'a', 'b', 'y']));
 *
 * @since 0.5.0
 */
export declare const insertMany: (i: number) => <A>(xs: NonEmptyArray<A>) => (ys: A[]) => Option<NonEmptyArray<A>>;
