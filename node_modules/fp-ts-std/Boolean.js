"use strict";
/**
 * @since 0.1.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.either = exports.both = exports.anyPass = exports.allPass = exports.xor = exports.or = exports.and = exports.invert = void 0;
const Semigroup_1 = require("fp-ts/Semigroup");
/**
 * Invert a boolean.
 *
 * @since 0.4.0
 */
exports.invert = x => !x;
/**
 * Returns `true` if both arguments are `true`, else `false`. Equivalent to
 * logical conjunction.
 *
 * @since 0.4.0
 */
exports.and = (x) => y => x && y;
/**
 * Returns `true` if one or both arguments are `true`, else `false`. Equivalent
 * to logical disjunction.
 *
 * @since 0.4.0
 */
exports.or = (x) => y => x || y;
/**
 * Returns `true` if one argument is `true` and the other is `false`, else
 * `false`. Equivalent to exclusive logical disjunction.
 *
 * @since 0.4.0
 */
exports.xor = (x) => y => (x && !y) || (!x && y);
/**
 * Given an array of predicates, returns a predicate that returns true if the
 * argument passes all of the predicates.
 *
 * @since 0.4.0
 */
exports.allPass = (fs) => x => fs.every(f => f(x));
/**
 * Given an array of predicates, returns a predicate that returns true if the
 * argument passes any of the predicates.
 *
 * @since 0.4.0
 */
exports.anyPass = (fs) => x => fs.some(f => f(x));
/**
 * Combine two predicates under conjunction.
 *
 * @example
 * import { both } from 'fp-ts-std/Boolean';
 * import { Predicate } from 'fp-ts/function';
 *
 * const gt5: Predicate<number> = x => x > 5;
 * const lt10: Predicate<number> = x => x < 10;
 * const gt5AndLt10: Predicate<number> = both(gt5)(lt10);
 *
 * assert.strictEqual(gt5AndLt10(3), false);
 * assert.strictEqual(gt5AndLt10(8), true);
 * assert.strictEqual(gt5AndLt10(12), false);
 *
 * @since 0.5.0
 */
exports.both = (f) => g => Semigroup_1.getFunctionSemigroup(Semigroup_1.semigroupAll)().concat(f, g);
/**
 * Combine two predicates under disjunction.
 *
 * @example
 * import { either } from 'fp-ts-std/Boolean';
 * import { Predicate } from 'fp-ts/function';
 *
 * const lt5: Predicate<number> = x => x < 5;
 * const gt10: Predicate<number> = x => x > 10;
 * const lt5OrGt10: Predicate<number> = either(lt5)(gt10);
 *
 * assert.strictEqual(lt5OrGt10(3), true);
 * assert.strictEqual(lt5OrGt10(8), false);
 * assert.strictEqual(lt5OrGt10(12), true);
 *
 * @since 0.5.0
 */
exports.either = (f) => g => Semigroup_1.getFunctionSemigroup(Semigroup_1.semigroupAny)().concat(f, g);
