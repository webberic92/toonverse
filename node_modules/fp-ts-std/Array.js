"use strict";
/**
 * @since 0.1.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertMany = exports.upsert = exports.pluckFirst = exports.getDisorderedEq = exports.join = exports.all = exports.any = exports.elemFlipped = exports.length = void 0;
const function_1 = require("fp-ts/function");
const NEA = require("fp-ts/NonEmptyArray");
const A = require("fp-ts/Array");
const O = require("fp-ts/Option");
const Foldable_1 = require("fp-ts/Foldable");
/**
 * Get the length of an array.
 *
 * @since 0.1.0
 */
exports.length = (xs) => xs.length;
/**
 * Like `fp-ts/Array::elem`, but flipped.
 *
 * @since 0.1.0
 */
exports.elemFlipped = (eq) => (xs) => y => A.elem(eq)(y)(xs);
/**
 * Check if a predicate holds true for any array member.
 *
 * @since 0.1.0
 */
exports.any = (f) => xs => xs.some(f);
/**
 * Check if a predicate holds true for every array member.
 *
 * @since 0.1.0
 */
exports.all = (f) => xs => xs.every(f);
/**
 * Join an array of strings together into a single string using the supplied
 * separator.
 *
 * @since 0.1.0
 */
exports.join = (x) => (ys) => ys.join(x);
/**
 * Like `fp-ts/Array::getEq`, but items are not required to be in the same
 * order to determine equivalence. This function is therefore less efficient,
 * and `getEq` should be preferred on ordered data.
 *
 * @since 0.1.0
 */
exports.getDisorderedEq = (ordA) => ({
    equals: (xs, ys) => {
        const sort = A.sort(ordA);
        return A.getEq(ordA).equals(sort(xs), sort(ys));
    },
});
/**
 * Pluck the first item out of an array matching a predicate. Any further
 * matches will be left untouched.
 *
 * This can be thought of as analagous to `fp-ts/Array::findFirst` where
 * the remaining items, sans the match (if any), are returned as well.
 *
 * @since 0.1.0
 */
exports.pluckFirst = (p) => (xs) => function_1.pipe(A.findIndex(p)(xs), O.fold(function_1.constant([O.none, xs]), (i) => [O.some(xs[i]), A.unsafeDeleteAt(i, xs)]));
/**
 * Update an item in an array or, if it's not present yet, insert it.
 *
 * If the item exists more than once (as determined by the supplied `Eq`
 * instance), only the first to be found will be updated. The order in which
 * the array is checked is unspecified.
 *
 * @since 0.1.0
 */
exports.upsert = (eqA) => (x) => (ys) => function_1.pipe(A.findIndex(y => eqA.equals(x, y))(ys), O.map((i) => A.unsafeUpdateAt(i, x, ys)), O.chain(NEA.fromArray), O.getOrElse(() => NEA.snoc(ys, x)));
/**
 * Insert all the elements of an array into another array at the specified
 * index. Returns `None` if the index is out of bounds.
 *
 * The array of elements to insert must be non-empty.
 *
 * @example
 * import { insertMany } from 'fp-ts-std/Array';
 * import * as O from 'fp-ts/Option';
 *
 * const f = insertMany(1)(['a', 'b']);
 * assert.deepStrictEqual(f([]), O.none);
 * assert.deepStrictEqual(f(['x']), O.some(['x', 'a', 'b']));
 * assert.deepStrictEqual(f(['x', 'y']), O.some(['x', 'a', 'b', 'y']));
 *
 * @since 0.5.0
 */
exports.insertMany = (i) => (xs) => (ys) => function_1.pipe(xs, A.reverse, Foldable_1.reduceM(O.Monad, A.Foldable)(ys, (zs, x) => function_1.pipe(zs, A.insertAt(i, x))), O.chain(NEA.fromArray));
