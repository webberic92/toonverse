import { PopulatedTransaction } from '@ethersproject/contracts';
import { NonceManager } from '@ethersproject/experimental';
import * as TE from 'fp-ts/TaskEither';
import * as t from 'io-ts';
import type { Stark } from '../contracts';
import { Registration } from '../contracts/registration';
import { EthAddress, FeeParams, ImmutableMethodParams, ImmutableMethodResults, OrderParams, PositiveBigNumber, RegistrationMethodParams, StarkMethodParams, Token, Transaction, TransferParams } from '../types';
export declare class ImmutableXController {
    private publicApiUrl;
    private signer;
    private accountMappingKey;
    private accountMapping;
    private activeKeyPair;
    private store;
    constructor(publicApiUrl: string, signer: NonceManager, accountMappingKey?: string);
    getAddress(): Promise<EthAddress>;
    get starkPublicKey(): string | undefined;
    getStarkPublicKey(path?: string): Promise<string>;
    getExchangeContract(contractAddress: string): Stark;
    getRegistrationContract(contractAddress: string): Registration;
    sign(payload: any): Promise<string>;
    signRaw(payload: string): Promise<string>;
    signStark(payload: any): Promise<string>;
    signRegistration(): Promise<string>;
    account(layer: string, application: string, index: string): Promise<string>;
    signUserRegistration({ etherKey, starkPublicKey, nonce, }: {
        etherKey: string;
        starkPublicKey: string;
        nonce: string;
    }): TE.TaskEither<Error, string>;
    signUserRegistrationVerifyEth({ etherKey, starkPublicKey, }: {
        etherKey: string;
        starkPublicKey: string;
    }): TE.TaskEither<Error, string>;
    signDeposit(starkPublicKey: string, vaultId: string, assetId: string, quantity: PositiveBigNumber, nonce: string): Promise<string>;
    signWithdraw(starkPublicKey: string, vaultId: string, token: Token, assetId: string, quantity: PositiveBigNumber, nonce: string): TE.TaskEither<Error, string>;
    transfer(from: TransferParams, to: TransferParams, token: Token, assetId: string, quantity: PositiveBigNumber, nonce: string, expirationTimestamp: string): TE.TaskEither<Error, string>;
    transferV2(transfers: ImmutableMethodResults.ImmutableGetSignableTransferV2Result): TE.TaskEither<Error, readonly ImmutableMethodParams.ImmutableTransferRequestV2[]>;
    createOrder(starkPublicKey: string, sell: OrderParams, buy: OrderParams, sell_id: string, buy_id: string, nonce: t.Int, expirationTimestamp: t.Int): TE.TaskEither<Error, string>;
    createOrderWithFee(starkPublicKey: string, sell: OrderParams, buy: OrderParams, sell_id: string, buy_id: string, nonce: t.Int, expirationTimestamp: t.Int, fee_info: FeeParams): TE.TaskEither<Error, string>;
    private getCancelOrderMsg;
    private signF;
    private serializeSignature;
    cancelOrder(orderId: string): TE.TaskEither<Error, string>;
    register({ contractAddress, etherKey, starkPublicKey, operatorSignature, }: StarkMethodParams.StarkRegisterParams): TE.TaskEither<Error, PopulatedTransaction>;
    depositF({ contractAddress, starkPublicKey, quantity, quantizedAmount, assetId, token, vaultId, }: StarkMethodParams.StarkDepositParams): TE.TaskEither<Error, PopulatedTransaction>;
    deposit(params: StarkMethodParams.StarkDepositParamsTS): Promise<Transaction>;
    registerAndDepositF({ registrationContractAddress, starkPublicKey, quantity, assetId, token, vaultId, etherKey, operatorSignature, }: RegistrationMethodParams.RegisterAndDepositParams): TE.TaskEither<Error, PopulatedTransaction>;
    depositCancel(contractAddress: string, starkPublicKey: string, token: Token, vaultId: string): Promise<Transaction>;
    depositReclaim(contractAddress: string, starkPublicKey: string, token: Token, vaultId: string): Promise<Transaction>;
    withdrawal(contractAddress: string, starkPublicKey: string, token: Token): TE.TaskEither<Error, PopulatedTransaction>;
    registerAndWithdraw({ registrationContractAddress, starkPublicKey, token, etherKey, operatorSignature, }: RegistrationMethodParams.RegisterAndWithdrawParams): TE.TaskEither<Error, PopulatedTransaction>;
    fullWithdrawal(contractAddress: string, starkPublicKey: string, vaultId: string): Promise<Transaction>;
    freeze(contractAddress: string, starkPublicKey: string, vaultId: string): Promise<Transaction>;
    escape(contractAddress: string, starkPublicKey: string, vaultId: string, token: Token, quantity: PositiveBigNumber): Promise<Transaction>;
    mintNFT(tokenAddress: string): TE.TaskEither<Error, Transaction>;
    approveNFT({ tokenAddress, contractAddress, tokenId, }: StarkMethodParams.StarkApproveNFTParams): TE.TaskEither<Error, Transaction>;
    approveERC20({ tokenAddress, amount, contractAddress, }: StarkMethodParams.StarkApproveERC20Params): TE.TaskEither<Error, Transaction>;
    private assertStarkPublicKey;
    private getActiveKeyPair;
    private setActiveKeyPair;
    private getKeyPairFromPath;
    private getAccountMapping;
    private isTokenERC20;
    private isTokenETH;
    private isTokenNFT;
    private getAssetTypeValue;
    private getQuantumValue;
}
