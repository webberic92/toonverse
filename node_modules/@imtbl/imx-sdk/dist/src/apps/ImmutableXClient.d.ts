import { AxiosRequestConfig } from 'axios';
import { BigNumber, Signer } from 'ethers';
import * as E from 'fp-ts/Either';
import * as T from 'fp-ts/Task';
import * as TE from 'fp-ts/TaskEither';
import { AddMetadataSchemaToCollectionParams, AddMetadataSchemaToCollectionResult, CreateCollectionParams, CreateCollectionsResult, CreateProjectParams, CreateProjectResult, ERC721Token, EthAddress, ExchangeProvider, GetMetadataSchemaParams, GetMetadataSchemaResult, GetProjectParams, HexadecimalString, ImmutableMethodParams, ImmutableMethodResults, MintableERC721Token, OrderParams, PositiveBigNumber, ProjectResult, ProjectsResult, Token, UpdateCollectionParams, UpdateCollectionsResults, UpdateMetadataSchemaByNameParams, UpdateMetadataSchemaByNameResult } from '../types';
import { ImmutableXWallet } from './ImmutableXWallet';
export declare type ImmutableXClientParams = {
    publicApiUrl: string;
    apiKey?: string;
    signer?: Signer;
    gasLimit?: string;
    gasPrice?: string;
    starkContractAddress?: string;
    registrationContractAddress?: string;
    enableDebug?: boolean;
};
export declare const V2 = "v2";
export declare class ImmutableXClient {
    private publicApiUrl;
    private wallet;
    private contractAddress;
    private registrationContractAddress;
    private _address;
    private _starkPublicKey;
    private enableDebug;
    private readonly apiKey?;
    private agent;
    private requests;
    constructor(publicApiUrl: string, wallet: ImmutableXWallet, contractAddress: EthAddress, registrationContractAddress: EthAddress, _address: EthAddress, _starkPublicKey: HexadecimalString, enableDebug?: boolean, apiKey?: string | undefined);
    static buildF(params: ImmutableXClientParams): TE.TaskEither<Error, ImmutableXClient>;
    getERC20Balance(owner: string, contractAddress: string): Promise<string>;
    getERC20Allowance(contractAddress: string, owner: string, spender?: string): Promise<string>;
    hasERC20Allowance(contractAddress: string, amount: string | BigNumber, owner: string, spender?: string): Promise<boolean>;
    static build({ publicApiUrl, signer, starkContractAddress, registrationContractAddress, gasLimit, gasPrice, enableDebug, apiKey, }: ImmutableXClientParams): Promise<ImmutableXClient>;
    get address(): import("io-ts").Branded<string, import("../types").EthAddressBrand>;
    get starkPublicKey(): import("io-ts").Branded<string, import("../types").HexadecimalStringBrand>;
    buildOptions(): AxiosRequestConfig;
    private replaceApiVersion;
    private get;
    private post;
    private delete;
    registerImxF({ etherKey, starkPublicKey, }: ImmutableMethodParams.ImmutableRegisterParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableRegisterResult>;
    getUserF(params: ImmutableMethodParams.ImmutableGetUserParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetUserResult>;
    getUser(params: ImmutableMethodParams.ImmutableGetUserParamsTS): Promise<{
        accounts: import("io-ts").Branded<string, import("../types").HexadecimalStringBrand>[];
    }>;
    registerImx(params: ImmutableMethodParams.ImmutableRegisterParamsTS): Promise<{
        tx_hash: string;
    }>;
    isRegisteredF(params: ImmutableMethodParams.ImmutableGetUserParams): TE.TaskEither<Error, boolean>;
    isRegistered(params: ImmutableMethodParams.ImmutableGetUserParamsTS): Promise<boolean>;
    isRegisteredStarkF(starkPublicKey: string): T.Task<boolean>;
    isRegisteredStark(starkPublicKey: string): Promise<boolean>;
    registerF(params: ImmutableMethodParams.ImmutableRegisterParams): TE.TaskEither<Error, string>;
    register(params: ImmutableMethodParams.ImmutableRegisterParamsTS): Promise<string>;
    registerStarkF({ etherKey, starkPublicKey, operatorSignature, }: ImmutableMethodParams.ImmutableStarkRegisterParams): TE.TaskEither<Error, string>;
    registerStark(params: ImmutableMethodParams.ImmutableStarkRegisterParamsTS): Promise<string>;
    getSignableRegistrationF({ etherKey, starkPublicKey, }: ImmutableMethodParams.ImmutableGetSignableRegistrationParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetSignableRegistrationResult>;
    getSignableRegistration(params: ImmutableMethodParams.ImmutableGetSignableRegistrationParamsTS): Promise<{
        operator_signature: string;
    }>;
    mintNFTF({ tokenAddress, }: ImmutableMethodParams.ImmutableMintNFTParams): TE.TaskEither<Error, string>;
    mintNFT(params: ImmutableMethodParams.ImmutableMintNFTParamsTS): Promise<string>;
    approveNFTF(params: ImmutableMethodParams.ImmutableStarkApproveNFTParams): TE.TaskEither<Error, string>;
    approveNFT(params: ImmutableMethodParams.ImmutableStarkApproveNFTParamsTS): Promise<string>;
    approveERC20F(params: ImmutableMethodParams.ImmutableStarkApproveERC20Params): TE.TaskEither<Error, string>;
    approveERC20(params: ImmutableMethodParams.ImmutableStarkApproveERC20ParamsTS): Promise<string>;
    depositF({ user, token, quantity, }: ImmutableMethodParams.ImmutableGetSignableDepositParams): TE.TaskEither<Error, string>;
    deposit(params: ImmutableMethodParams.ImmutableGetSignableDepositParamsTS): Promise<string>;
    depositCancel(starkPublicKey: string, token: Token, vaultId: string): Promise<any>;
    depositReclaim(starkPublicKey: string, token: Token, vaultId: string): Promise<any>;
    prepareWithdrawalF({ user, token, quantity, }: ImmutableMethodParams.ImmutablePrepareWithdrawalParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableWithdrawalResult>;
    prepareWithdrawal(params: ImmutableMethodParams.ImmutablePrepareWithdrawalParamsTS): Promise<ImmutableMethodResults.ImmutableWithdrawalResult>;
    processMintableToken(mintableToken: ImmutableMethodResults.ImmutableGetMintableTokenResult, token: ERC721Token): MintableERC721Token;
    completeWithdrawalF({ starkPublicKey, token, }: ImmutableMethodParams.ImmutableCompleteWithdrawalParams): TE.TaskEither<Error, string>;
    completeWithdrawal(params: ImmutableMethodParams.ImmutableCompleteWithdrawalParamsTS): Promise<string>;
    transferF({ sender, token, quantity, receiver, }: ImmutableMethodParams.ImmutableTransferParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableTransferResult>;
    transfer(params: ImmutableMethodParams.ImmutableTransferParamsTS): Promise<ImmutableMethodResults.ImmutableTransferResult>;
    burnF({ sender, token, quantity, }: ImmutableMethodParams.ImmutableBurnParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableBurnResult>;
    burn(params: ImmutableMethodParams.ImmutableBurnParamsTS): Promise<ImmutableMethodResults.ImmutableBurnResult>;
    signMessage(message: ImmutableMethodParams.ImmutableSignParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableSignResult>;
    mintF(params: ImmutableMethodParams.ImmutableOffchainMintParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableOffchainMintResults>;
    mint(params: ImmutableMethodParams.ImmutableOffchainMintParamsTS): Promise<ImmutableMethodResults.ImmutableOffchainMintResults>;
    mintV2F(params: ImmutableMethodParams.ImmutableOffchainMintV2Params): TE.TaskEither<Error, ImmutableMethodResults.ImmutableOffchainMintV2Results>;
    mintV2(params: ImmutableMethodParams.ImmutableOffchainMintV2ParamsTS): Promise<ImmutableMethodResults.ImmutableOffchainMintV2Results>;
    mintV2Testing(params: ImmutableMethodParams.ImmutableOffchainMintV2ParamsTS): Promise<ImmutableMethodResults.ImmutableOffchainMintV2Results>;
    calculateMakerOrderAmountsF(params: ImmutableMethodParams.ImmutableGetSignableOrderParams): TE.TaskEither<Error, {
        amountSell: PositiveBigNumber;
        amountBuy: PositiveBigNumber;
    }>;
    createOrderRequestF({ user, tokenSell, tokenBuy, amountSell, amountBuy, include_fees, fees, expiration_timestamp, }: ImmutableMethodParams.ImmutableGetSignableOrderParams): TE.TaskEither<Error, {
        signableOrderResult: ImmutableMethodResults.ImmutableGetSignableOrderResult;
        sellParams: OrderParams;
        buyParams: OrderParams;
        signature: string;
    }>;
    private formatFeesForRequest;
    private formatAuxiliaryFeesForQueryString;
    createOrderF({ user, tokenSell, tokenBuy, amountSell, amountBuy, include_fees, fees, expiration_timestamp, }: ImmutableMethodParams.ImmutableGetSignableOrderParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableCreateOrderResult>;
    createOrder(params: ImmutableMethodParams.ImmutableGetSignableOrderParamsTS): Promise<ImmutableMethodResults.ImmutableCreateOrderResult>;
    cancelOrderF(orderId: ImmutableMethodParams.ImmutableCancelOrderParamsTS): TE.TaskEither<Error, ImmutableMethodResults.ImmutableCancelOrderResult>;
    cancelOrder(params: ImmutableMethodParams.ImmutableCancelOrderParamsTS): Promise<ImmutableMethodResults.ImmutableCancelOrderResult>;
    createTradeF({ user, tokenSell, tokenBuy, amountSell, amountBuy, orderId, include_fees, fees, }: ImmutableMethodParams.ImmutableGetSignableTradeParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableCreateTradeResult>;
    createTrade(params: ImmutableMethodParams.ImmutableGetSignableTradeParamsTS): Promise<ImmutableMethodResults.ImmutableCreateTradeResult>;
    getTokenF(params: ImmutableMethodParams.ImmutableGetTokenParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetTokenResult>;
    getToken(params: ImmutableMethodParams.ImmutableGetTokenParamsTS): Promise<ImmutableMethodResults.ImmutableGetTokenResult>;
    listTokensF(params: ImmutableMethodParams.ImmutableListTokensParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableListTokensResult>;
    listTokens(params: ImmutableMethodParams.ImmutableListTokensParamsTS): Promise<ImmutableMethodResults.ImmutableListTokensResult>;
    getBalancesF(params: ImmutableMethodParams.ImmutableGetBalancesParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetBalancesResult>;
    getBalances(params: ImmutableMethodParams.ImmutableGetBalancesParams): Promise<ImmutableMethodResults.ImmutableGetBalancesResult>;
    getBalanceF(params: ImmutableMethodParams.ImmutableGetBalanceParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetBalanceResult>;
    getBalance(params: ImmutableMethodParams.ImmutableGetBalanceParamsTS): Promise<ImmutableMethodResults.ImmutableGetBalanceResult>;
    listBalancesF({ user, symbols, cursor, }: ImmutableMethodParams.ImmutableListBalancesParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableListBalancesResult>;
    listBalances(params: ImmutableMethodParams.ImmutableListBalancesParamsTS): Promise<ImmutableMethodResults.ImmutableListBalancesResult>;
    getMintableTokenF(params: ImmutableMethodParams.ImmutableGetMintableTokenParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetMintableTokenResult>;
    getMintableToken(params: ImmutableMethodParams.ImmutableGetMintableTokenParamsTS): Promise<ImmutableMethodResults.ImmutableGetMintableTokenResult>;
    getVaults(starkPublicKey: string): Promise<any>;
    getOrderF({ orderId, include_fees, auxiliaryFees, }: ImmutableMethodParams.ImmutableGetOrderParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetOrderResult>;
    getOrder(params: ImmutableMethodParams.ImmutableGetOrderParamsTS): Promise<ImmutableMethodResults.ImmutableGetOrderResult>;
    getOrdersF(query: ImmutableMethodParams.ImmutableGetOrdersParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetOrdersResult>;
    getOrders(params?: ImmutableMethodParams.ImmutableGetOrdersParamsTS): Promise<ImmutableMethodResults.ImmutableGetOrdersResult>;
    getAssetsF(query: ImmutableMethodParams.ImmutableGetAssetsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetAssetsResult>;
    getAssets(params?: ImmutableMethodParams.ImmutableGetAssetsParamsTS): Promise<ImmutableMethodResults.ImmutableGetAssetsResult>;
    getAssetF({ address, id, include_fees, }: ImmutableMethodParams.ImmutableGetAssetParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableAsset>;
    getAsset(params: ImmutableMethodParams.ImmutableGetAssetParamsTS): Promise<ImmutableMethodResults.ImmutableAsset>;
    getApplicationsF(query?: ImmutableMethodParams.ImmutableGetApplicationsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetApplicationsResult>;
    getApplications(params?: ImmutableMethodParams.ImmutableGetApplicationsParamsTS): Promise<ImmutableMethodResults.ImmutableGetApplicationsResult>;
    getTradeF({ id, }: ImmutableMethodParams.ImmutableGetTradeParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableTrade>;
    getTrade(params: ImmutableMethodParams.ImmutableGetTradeParamsTS): Promise<ImmutableMethodResults.ImmutableTrade>;
    getCollectionsF(query: ImmutableMethodParams.ImmutableGetCollectionsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetCollectionsResult>;
    getCollections(params: ImmutableMethodParams.ImmutableGetCollectionsParamsTS): Promise<ImmutableMethodResults.ImmutableGetCollectionsResult>;
    getCollectionF({ address, }: ImmutableMethodParams.ImmutableGetCollectionParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableCollection>;
    getCollection(params: ImmutableMethodParams.ImmutableGetCollectionParamsTS): Promise<ImmutableMethodResults.ImmutableCollection>;
    getDepositsF(query?: ImmutableMethodParams.ImmutableGetDepositsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetDepositsResult>;
    getDeposits(params?: ImmutableMethodParams.ImmutableGetDepositsParamsTS): Promise<ImmutableMethodResults.ImmutableGetDepositsResult>;
    getDepositF({ id, }: ImmutableMethodParams.ImmutableGetDepositParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableDeposit>;
    getDeposit(params: ImmutableMethodParams.ImmutableGetDepositParamsTS): Promise<ImmutableMethodResults.ImmutableDeposit>;
    getTransferF({ id, }: ImmutableMethodParams.ImmutableGetTransferParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableTransfer>;
    getTransfer(params: ImmutableMethodParams.ImmutableGetTransferParamsTS): Promise<ImmutableMethodResults.ImmutableTransfer>;
    private getSignableTransferV2F;
    private getSignableTransferV2;
    private convertToGetSignableTransferV2Params;
    transferV2F(params: ImmutableMethodParams.ImmutableTransferV2Params): TE.TaskEither<Error, ImmutableMethodResults.ImmutableTransferV2Result>;
    transferV2(params: ImmutableMethodParams.ImmutableTransferV2ParamsTS): Promise<ImmutableMethodResults.ImmutableTransferV2Result>;
    getBurn(params: ImmutableMethodParams.ImmutableGetBurnParamsTS): Promise<ImmutableMethodResults.ImmutableBurn>;
    getWithdrawalF({ id, }: ImmutableMethodParams.ImmutableGetWithdrawalParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableWithdrawal>;
    getWithdrawal(params: ImmutableMethodParams.ImmutableGetWithdrawalParamsTS): Promise<ImmutableMethodResults.ImmutableWithdrawal>;
    getWithdrawalsF(query?: ImmutableMethodParams.ImmutableGetWithdrawalsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetWithdrawalsResult>;
    getWithdrawals(params?: ImmutableMethodParams.ImmutableGetWithdrawalsParamsTS): Promise<ImmutableMethodResults.ImmutableGetWithdrawalsResult>;
    getTransfersF(query?: ImmutableMethodParams.ImmutableGetTransfersParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetTransfersResult>;
    getTransfers(params?: ImmutableMethodParams.ImmutableGetTransfersParamsTS): Promise<ImmutableMethodResults.ImmutableGetTransfersResult>;
    getExchangesV1F(params?: ImmutableMethodParams.ImmutableGetExchangesParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetExchangeHistoryResultV1>;
    getExchangesV1(params?: ImmutableMethodParams.ImmutableGetExchangesParamsTS): Promise<ImmutableMethodResults.ImmutableGetExchangeHistoryResultV1>;
    getExchangesF(params?: ImmutableMethodParams.ImmutableGetExchangesParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetExchangeHistoryResult>;
    getExchanges(params?: ImmutableMethodParams.ImmutableGetExchangesParamsTS): Promise<ImmutableMethodResults.ImmutableGetExchangeHistoryResult>;
    getBurnsF(query?: ImmutableMethodParams.ImmutableGetBurnsParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetBurnsResult>;
    getBurns(params?: ImmutableMethodParams.ImmutableGetBurnsParamsTS): Promise<ImmutableMethodResults.ImmutableGetBurnsResult>;
    getTradesF(query?: ImmutableMethodParams.ImmutableGetTradesParams): TE.TaskEither<Error, ImmutableMethodResults.ImmutableGetTradesResult>;
    getPaginatedResults<P, T>(params: P, fn: (params: P) => TE.TaskEither<Error, {
        cursor: string;
        result: T[];
    }>): TE.TaskEither<Error, T[]>;
    getTrades(params?: ImmutableMethodParams.ImmutableGetTradesParamsTS): Promise<ImmutableMethodResults.ImmutableGetTradesResult>;
    getLastAvailableNonce(starkPublicKey: string): Promise<{
        Nonce: string;
    }>;
    getTokenBody(token: Token): any;
    parseTokenBody(token: any): any;
    decodeImmutableGetSignableTransferV2Result(result: any): E.Either<never, {
        signable_responses: any;
        sender_stark_key: any;
    }>;
    private decodeForFunction;
    createExchangeV1(walletAddress: string): Promise<ImmutableMethodResults.ImmutableCreateExchangeResultV1>;
    createExchange(walletAddress: string, provider?: ExchangeProvider): Promise<ImmutableMethodResults.ImmutableCreateExchangeResult>;
    getExchangeV1(exchange_id: number): Promise<ImmutableMethodResults.ImmutableGetExchangeResultV1>;
    getExchange(exchange_id: number): Promise<ImmutableMethodResults.ImmutableGetExchangeResult>;
    getMoonpaySignature(req: ImmutableMethodResults.ImmutableGetMoonpaySignatureRequest, version?: 'v1' | 'v2'): Promise<ImmutableMethodResults.ImmutableGetMoonpaySignatureResult>;
    getMoonpaySellSignature(req: ImmutableMethodResults.ImmutableGetMoonpaySellSignatureRequest, version?: 'v1' | 'v2'): Promise<ImmutableMethodResults.ImmutableGetMoonpaySignatureResult>;
    handleSignatureRequest(version: any, body: any): Promise<{
        request: string;
        signature: string;
    }>;
    private getAuthenticationHeaders;
    createProject(params: CreateProjectParams): Promise<CreateProjectResult>;
    getProjects(params?: ImmutableMethodParams.ImmutablePaginatedParamsTS): Promise<ProjectsResult>;
    getProject(params: GetProjectParams): Promise<ProjectResult>;
    createCollection(params: CreateCollectionParams): Promise<CreateCollectionsResult>;
    updateCollection(contractAddress: string, params: UpdateCollectionParams): Promise<UpdateCollectionsResults>;
    addMetadataSchemaToCollection(contractAddress: string, params: AddMetadataSchemaToCollectionParams): Promise<AddMetadataSchemaToCollectionResult>;
    updateMetadataSchemaByName(name: string, contractAddress: string, params: UpdateMetadataSchemaByNameParams): Promise<UpdateMetadataSchemaByNameResult>;
    getMetadataSchema(params: GetMetadataSchemaParams): Promise<GetMetadataSchemaResult>;
}
export default ImmutableXClient;
