import colors from 'colors';
import moment from 'moment';
import winston from 'winston';

import { Encoder, Handler, ImLogger, ImLoggerConfig, Levels } from '.';

const levelMap: Record<Levels, string> = {
    INFO: 'info',
    DEBUG: 'debug',
    WARN: 'warn',
    ERROR: 'error',
};

function getTransport(handler: Handler): winston.transport {
    if (handler.type === 'console') {
        return new winston.transports.Console();
    } else if (handler.type === 'file') {
        return new winston.transports.File({ filename: handler.filename });
    }
    throw new Error('Unknown sink type');
}

const humanFormatter = winston.format.printf((info) => {
    const colorMap: Record<string, (text: string) => string> = {
        debug: colors.cyan,
        info: colors.green,
        warn: colors.yellow,
        error: colors.red,
    };

    const colorize = (level: string, text: string): string => {
        if (level in colorMap) {
            return colorMap[level](text);
        }
        return text;
    };

    let text = `${info.level.toUpperCase()} ${info.time} ${info.message} | component=${info.component}`;

    const extra = JSON.stringify(info.extra);
    if (!extra || extra.length < 30) {
        text += ` extra=${extra}`;
    } else {
        text += `\nextra=${JSON.stringify(info.extra, null, 2)}`;
    }

    if ('stack' in info) {
        text += `\n${info.stack}`;
    }

    return colorize(info.level, text);
});

const formatterMap: Record<Encoder, winston.Logform.Format> = {
    json: winston.format.json(),
    human: humanFormatter,
};

export class WinstonLogger implements ImLogger {
    loggers: winston.Logger[] = [];
    constructor(private config: ImLoggerConfig) {
        this.loggers = config.handlers.map((handler) => {
            return winston.createLogger({
                level: levelMap[config.level],
                format: formatterMap[handler.encoder],
                defaultMeta: { service: 'user-service' },
                transports: getTransport(handler),
            });
        });
    }

    log(level: string, component: string, message?: string, extra?: any, error?: Error) {
        if (this.config.componentFilter.length > 0) {
            const index = this.config.componentFilter.indexOf(component);
            if (index < 0) {
                return;
            }
        }

        for (const logger of this.loggers) {
            const info = {
                appName: this.config.appName,
                appVersion: this.config.appVersion,
                time: moment().format(),
                component,
                message,
                extra,
            };

            if (level === 'DEBUG') {
                logger.debug(info);
            } else if (level === 'INFO') {
                logger.info(info);
            } else if (level === 'WARN') {
                logger.warn(info);
            } else if (error && level === 'ERROR') {
                logger.error({ stack: error.stack, ...info });
            }
        }
    }

    debug(component: string, message: string, extra: any): void {
        this.log('DEBUG', component, message, extra);
    }

    info(component: string, message: string, extra?: any): void {
        this.log('INFO', component, message, extra);
    }

    warn(component: string, message: string, extra: any): void {
        this.log('WARN', component, message, extra);
    }

    error(component: string, error: Error, extra: any): void {
        this.log('ERROR', component, error.message, extra, error);
    }
}
